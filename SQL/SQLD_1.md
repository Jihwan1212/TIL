---
contents: 2025년 2월 28일 금요일
tags:
  - "#데이터모델링"
  - "#스키마"
  - "#ERD"
  - "#엔터티"
  - "#속성"
  - "#관계"
  - "#정규화"
  - "#Key"
  - "#SQL"
---

# 1장. 데이터 모델링의 이해
## 데이터모델의 이해 
### 데이터 모델
- 현실 세계의 비즈니스 프로세스와 데이터 요구 사항을 추상적, 구조화된 형태로 표현하는 과정
	- 데이터 모델의 특징
		- 단순화: 불필요한 세부 사항을 제거
		- 추상화: 간략하게 대략적으로 표현하는 과정
		- 명확화: 정확하게 현상을 기술하는 과정
		- (현실세계) → **추상화, 단순화, 정확화** → (모델)
	- 데이터 모델링 3가지 관점
		- 데이터 관점
		- 프로세스 관점
		- 데이터와 프로세스 관점
	- 데이터 모델링 유의점 *중유일*
		- **중복** : 같은 시간 같은 데이터 제공
		- **비유연성** : 사소한 업무변화에 데이터 모델이 수시로 변경되면 안됨 / 데이터 정의를 사용, 프로세스와 분리
		- **비일관성** : 데이터 간 상호 연관 관계에 대해 명확히 정의해야 함
	- 데이터 모델링 3가지 요소
		- 대상(Entity): 관리하고자 하는 객체
		- 속성(Attributes): 하나의 특징으로 정의될 수 있는 것
		- 관계(Relationships): 대상들 간의 관계  
	- 데이터 모델링의 3단계 *개논물*
		- **개념적 모델링**
			- 업무 중심적, 포괄적 수준
			- 추상화 수준이 가장 높음
			- *핵심 엔터티를 추출*하는 단계
			- 핵심 엔터티들과의 관계들을 표현하기 위해 *ERD작성
		- **논리적 모델링**
			- 개념적 모델링 토대로 *세부속성, 식별자, 관계 등을 표현하는 단계
			- *데이터 정규화 수행
			- 동일한 형태의 데이터 사용 시 재사용 가능
		- **물리적 모델링**
			- 논리 모델링 후 이를 직접 물리적으로 생성하는 과정
			- 추상화 수준은 가장 낮음(가장 구체적)

### 스키마
- 데이터 베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
	- 스키마의 3단계 구조 *외개내*
		- **외부 스키마**
			- 개개(*여러*) 사용자가 보는 개인적 DB 스키마
		- **개념 스키마**
			- *모든 사용자 관점을 통합*한 전체 DB
			- 데이터 베이스의 전체 *논리적 구조*를 정의
		- **내부 스키마**
			- *물리적*으로 어떻게 저장되는지를 정의
			- 데이터 저장 구조, 컬럼, 인덱스 등을 정의
	- Mapping(사상): 상호 독립적인 개념을 연결시켜주는 다리
		- **논리적 사상** : 외부 스키마 → 개념 스키마
		- **물리적 사상** : 개념 스키마 → 내부 스키마
	- 3단계 스키마의 독립성
		- **논리적 독립성** : 개념스키마 변경 → 외부스키마에 영향 X
		- **물리적 독립성** : 내부스키마 변경 → 외부/개념스키마에 영향 X

### 데이터 모델 표기법 
- ERD: Entity Relationship Diagram
- 엔터티와 엔터티 간의 관계를 시각적으로 표현한 다이어그램
- 1976년 피터첸이 Entity Relationship Model 개발
- IE, Baker 기법이 많이 쓰임
	- ERD 작성 절차 (6단계)
		- 엔터티 그림
		- 엔터티 배치
		- 엔터티 관계 설정
		- 관계명 기술
		- 관계의 참여도 기술
		- 관계 필수 여부


## 엔터티
- 현실 세계에서 독립적으로 식별 가능한 객체나 사물을 나타냄
- 업무상 분석해야 하는 대상들로 이루어진 집합
	- 엔터티 예시
		- 엔터티: 학생
		- 속성: 학번, 이름, 학과
		- 식별자: 학번
		- 인스턴스: 특정 학생의 데이터
			- 학번:2017120330
			- 이름: 양지환
			- 학과: 경영학과
	- 엔터티의 특징
		- 유일한 식별자에 의해 식별 가능
			- 이름은 동명이인 가능 -> 사번
		- 반드시 해당 업무에서 필요하고 관리하고자 함
		- *두 개 이상의 인스턴스가 있어야 함
		- *두 개 이상의 속성이 있어야 함
		- 업무 프로세스에 의해 이용되어야 함
		- 다른 엔터티와 최소 1개 이상의 관계가 있어야 함
	- 엔터티의 분류
		- 1. 유무형에 따른 분류
			- **유형 엔터티** : 물리적 형태 → 예) 사원, 물품, 강사
			- **개념 엔터티** : 개념적 정보 → 예) 조직, 보험상품
			- **사건 엔터티** : 업무수행 시 발생 → 예) 주문, 청구, 미납
		- 2. 발생 시점에 따른 분류
			- **기본 엔터티** 
				- 업무에 원래 존재하는 정보
				- 다른 엔터티의 부모 역할, 자신의 고유한 주식별자 가짐
				- 예) 사원, 부서
			- **중심 엔터티**
				- 기본 엔터티로부터 발생
				- 다른 엔터티와 관계로 많은 행위 엔터티 생성
				- 예) 계약, 사고, 주문
			- **행위 엔터티**
				- 2개 이상의 부모 엔터티로부터 발생
				- 자주 바뀌거나 양이 증가
				- 예) 주문목록, 사원변경이력
	- 엔터티의 명명
		- 현업에서 사용하는 용어 사용
		- 약어 사용 금지
		- 단수 명사 사용
		- 고유한 이름 사용
		- 생성 의미대로 부여

## 속성
- 업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 **분리되지 않는 최소의 데이터 단위**
- **컬럼**으로 표현할 수 있는 단위
	- 속성의 특징
		- 반드시 해당 업무에서 필요
		- **종속성**
			- a속성의 값에 의해 다른 속성b도 유일하게 결정된다면 a->b로 표현
				- 완전 함수적 종속
				- 부분 함수적 종속 
		- **원자성
			- 하나의 속성은 한 개의 값만을 가짐
			- 인스턴스가 해당 속성에 대해 단일하고 명확한 값을 가지는 것
	- 속성의 분류
		- 속성의 특성에 따른 분류
			- **기본 속성**
				- 업무로부터 추출한 모든 일반적인 속성
			- **설계 속성**
				- 업무를 규칙화하기 위해 새로 만들거나 변형, 정의하는 속성
				- 예: 일련번호
			- **파생 속성**
				- 다른 속성에 영향을 받아 발생하는 속성
				- 빠른 성능을 낼 수 있도록 원래 속성의 값을 계산해 적을수록 좋음
				- 예: 합계, 평균, 이자
		- 엔터티 구성방식에 따른 분류
			- PK (Primary Key)
				- 인스턴스를 식별할 수 있는 속성
				- 기본키, 주식별자
			- FK (Foreign Key)
				- 다른 엔터티와의 관계에서 포함된 속성
				- 외래키
			- 일반 속성
				- PK, FK에 포함되지 않는 속성
		- 분해 여부에 따른 속성
			- 단일 속성
				- 하나의 의미로 구성된 경우
			- 복합 속성
				- 여러개의 의미로 구성된 경우
				- 주소(시, 구, 동으로 분해 가능)
			- 다중값 속성
				- 속성에 여러 개의 값을 가질 수 있는 경우
				- 상품리스트
	- 속성의 명명규칙
		- 해당 업무에서 사용하는 이름 부여
		- 서술식 속성명 사용 금지
		- 약어 사용 금지
		- 구체적으로 명명하여 데이터 모델에서 유일성 확보
	- 엔터티 vs 인스턴스 vs 속성 vs 속성값
		- 한 개의 엔터티는 2개 이상의 인스턴스 집합
		- 한 개의 엔터티는 2개 이상의 속성을 가짐
		- 한 개의 속성은 1개의 속성값을 가짐

### 도메인 (Domain)
- 각 속성이 가질 수 있는 값의 범위
- 속성에 대한 데이터 타입, 크기, 제약사항 지정


## 관계
- 엔터티간의 연관성을 나타낸 개념
- 관계의 종류
	- 존재적 관계
		- 한 엔터티의 존재가 다른 엔터티의 존재에 영향
	- 행위적 관계
		- 엔터티 간의 어떤 행위가 있는 것을 의미
	- *ERD에서는 존재관계와 행위관계를 구분하지 않음
- 관계의 구성
	- 관계명
	- 차수 (Cardinality)
		- **1대1 관계**
			- 완전 1대1 관계
				- 사원은 반드시 소속 부서가 있어야 함
			- 선택적 1대1 관계
				- 사원은 하나의 소속 부서가 있거나 발령전이면 없을 수도
		- **1대N 관계**
			- 고객은 여러 개 계좌를 소유할 수 있음
		- **M대N 관계**
			- 조인 시 카테시안 곱이 발생
			- 두 엔터티를 연결하는 연결엔터티의 추가로 1대N 관계로 해소할 필요
				- 한 학생이 여러 강의 수강할 수 있고, 한 강의 기준으로도 여러 학생이 보유 가능
				- 이 두 엔터티의 연결엔터티로는 구매이력 엔터티가 필요할 것(해소)
### 관계의 페어링
- 엔터티 안에 인스턴스가 개별적으로 관계를 가지는 것
- 관계란 페어링의 집합을 의미
	- 인스턴스 관계를 보면 a학생이 강의b를 수강후 A성적을 받았다와 같은 페어링이 형성
- **차수**는 하나의 텐터티와 다른 엔터티 간의 레코드 연결 방식을 나타냄
- **페어링**은 두 엔터티 간의 특정 연결을 설명


## 식별자
- 엔터티를 대표할 수 있는 속성을 나타냄
- 엔터티 내에서 인스턴스를 구분하는 구분자
- 하나의 유일한 식별자가 존재해야 함
- **논리 모델링**에서는**식별자**라고 표현
	- 학생 엔터티의 주식별자는 학생번호 속성
- **물리 모델링**에서는 [[#Key]]라고 표현
	- 학생 테이블의 기본키는 학생번호 컬럼
- 주식별자의 특징
	- **유일성** : 주식별자에 의해 모든 인스턴스들이 유일하게 구분
	- **최소성** : 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
	- **불변성** : 지정된 주식별자의 값은 자주 변하지 않아야 하며, 변하면 이전 기록이 말소됨
	- **존재성** : 주식별자가 지정되면 반드시 값이 들어와야 함, NULL은 허용 안 됨
- 식별자 분류
	- 1. 대표성 여부에 따른 종류
		- **주식별자**
			- 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자
			- 타 엔터티와 참조관계를 연결
		- **보조식별자**
			- 구분자이나 대표성 없음
			- 참조관계 연결 없음
	- 2. 생성 여부에 따른 식별자의 종류
		- **내부식별자**
			- 다른 엔터티 참조 없이 엔터티 내부에서 스스로 생성
		- **외부식별자**
			- 다른 엔터티와 관계로 인하여 만들어지는 식별자(외래키)
	- 3. 속성 수에 따른 식별자 종류
		- **단일식별자**: 하나의 속성으로 구성
		- **복합식별자**: 2개 이상의 속성으로 구성
	- 4. 대체 여부에 따른 식별자의 종류
		- **본질식별자**(원조식별자)
			- 비즈니스 프로세스에서 만들어지는 식별자
		- **인조식별자**
			- 인위적으로 만들어지는 식별자
- 주식별자 도출기준
	- 해당 업무에서 자주 이용되는 속성인지 확인
	- 명칭, 내역 등  *이름으로 기술되는 것들은 사용하지 않음
		- 부서명 보다는 부서코드를 부여해 주식별자로 사용
	- *속성의 수를 최대한 적게 구성
		- 7-8개 이상의 주식별자 구성은 새로운 인조식별자를 생성하는 것이 좋음
- 관계간 엔터티 구분
	- **강한 개체**:독립적으로 존재할 수 있는 엔터티
		- 고객과 계좌(고객은 독립적으로 존재할 수 있음)
	- **약한 개체**:독립적으로 존재할 수 없는 엔터티
		- 고객과 계좌(계좌는 독립적으로 존재할 수 없음)
- *식별/비식별관계
	- *식별관계
		- 하나의 엔터티의 **기본키**를 다른 엔터티가 **기본키** 하나로 공유하는 관계
		- 식별관계는 ERD에서 실선으로 표시
	- *비식별관계
		- 강한 개체의 기본키를 다른 엔터티의 기본키가 아닌 일반 속성으로 관계
		- 비식별관계는 ERD에서 점선으로 표시
- [[#식별자 구분]]: 본질식별자vs인조식별자

### Key
- **기본키**(primary key)
	- 엔터티를 대표할 수 있는 키
- **후보키**(candidate key)
	- 유일성과 최소성을 만족하는 키
	- 결국 후보키들 중 하나가 기본키가 됨
	- 나머지를 대체키로 분류
- **대체키**(alternate key)
	- 여러 후보키 중 기본키가 아닌 키
- **슈퍼키**
	- 유일성은 만족하지만 최소성은 만족하지 않는 키
		- 학생테이블, 학번만으로 pk구성 가능
		- 그러나 학번 + 이름으로 구성한다면 이는 슈퍼키
- **외래키**(foreign key)
	- 다른 테이블의 기본키를 참조하는 키
	- 참조 테이블은 하나 또는 여러 개 가능



# 2장. 데이터 모델과 SQL
## 정규화
- 최소한의 데이터만을 하나의 엔터티에 넣는식으로 데이터를 분해하는 과정
- 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록
- 중복을 제거하고 데이터 모델의 독립성을 확보
- **이상현상**을 줄이기 위한 DB설계 기법
	- **정규화를 하지 않아 발생하는 현상**
	- 불필요한 값까지 입력해야 되는 현상을 **삽입이상**
	- 그외 **갱신** 및 **삭제 이상** 발생 가능
- 논리 데이터 모델링 수행 시점에서 고려

### 정규화 단계
- *제 1 정규화
	- 데이블이 칼럼이 **원자성**을 갖도록 테이블을 분해하는 단계
	- 하나의 행과 컬럼의 값이 **반드시 한 값만 입력**되도록 행을 분리하는 단계
- *제 2 정규화
	- 제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만들도록 테이블 분해
		- **기본키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 상태**
	- 기본키의 부분 집합이 다른 컬럼과 1:1 대응 관계를 갖지 않는 상태
	- PK가 2개 이상일 때 발생하며 PK의 일부와 종속되는 관계가 있다면 분리
- *제 3 정규화
	- 제 2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블 분리
		- **a->b, b->c 의 관계가 성립할 때, a->c 가 성립되는 것**
		- (a,b)와 (b,c)로 분리하는 것이 제 3 정규화


- 반정규화 (시험에 출제X)
	- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능 향상과 개발 및 운영의 단순화를 위함
	- 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법
	- 조회 시 디스크 I/O가 많거나 경로가 멀어 조인에 의한 성능 저하를 막기 위함
	- 일반적으로 정규화 시 입력/수정/삭제 성능이 향상되며, 반정규화 시 조인 성능이 향상

## 관계와 조인
### [[#관계]]
- 엔터티의 인스턴스 사이의 논리적인 연관성
- "관계를 맺는다"
	- 부모 식별자를 자식에게 상속
	- 상속된 속성을 매핑키로 활용
- 두 테이블이 관계를 맺게 되면 조인이라는 연결이 필요

### 조인
- 데이터의 중복을 피하기 위해 테이블은 정규화에 의해 분리
- 두 테이블은 관계를 맺음
- 두 테이블의 데이터를 동시에 출력하기 위해서는 조인이 필요

## 트랜잭션
- 하나의 연속적인 업무 단위
- 필수적인 관계 형태
- 하나의 트랜잭션에는 여러 SELECT, INSERT, UPDATE 등이 포함될 수 있음
	- **예시: a고객이 b고객에게 1만원 이체 가정**
		- 1. a고객 잔액이 1만원 이상인지 확인
		- 2. 이상이면 a고객 잔액을 -1만원 update
		- 3. b고객 잔액에 +1만원 update
			- 2,3번은 동시에 수행되어야 함
		- 트랜잭션은 이런 특성을 갖는 연속적인 업무단위
		- 주의사항
			- a고객 잔액 차감 & b고객 잔액 가산이 독립적으로 발생하면 안됨
			- 부분 COMMIT 불가
				- 동시 commit 또는 rollback 처리
	- **필수적, 선택적 관계와 ERD**
		- 두 엔터티의 관계가 서로 **필수적**일 때 하나의 트랜잭션을 형성
		- 두 엔터티가 독립적 수행이 가능하다면 **선택적** 관계로 표현
		- IE표기법
			- 필수적 관계: 원을 그리지 않음
			- 선택적 관계: 원을 그림
		- 바커표기법
			- 필수적 관계: 관계선을 실선으로 표기
			- 선택적 관계: 관계선을 점선으로 표기

## Null
- 아직 정해지지 않은 값을 의미
- 0과 빈문자열과는 다른 개념
	- Null 의 특성
		- Null을 포함한 연산 결과는 항상 Null
		- **그룹 함수**는 Null을 제외하고 연산을 수행
			- **SUM, AVG, MIN, MAX**
			- COUNT는 Null을 세지 않음
		- IE표기법에서는 Null 허용여부를 알 수 없음
		- 바커 표기업에서는 속성 앞 동그라미가 Null허용 속성을 의미

## 식별자 구분
- **본질 식별자**
	- 업무에 의해 만들어지는 꼭 필요한 식별자
- **인조 식별자**
	- 꼭 필요하지 않음
	- 편이성을 이유로 인위적으로 만들어지는 식별자
	- 인조 식별자의 단점
		- 중복 데이터 발생 가능성
		- 불필요한 인덱스 생성(저장 공간 낭비)
		- DML시 INDEX PLIT현상으로 성능 저하



 

 

 

 

 

 

 

 

 

 
